[0.0204]	alphax;
[0.0242]	alphay;
[0.0076]	betax;
[0.0168]	betay;
[0.0]		k1;
[2.0]		k2;
[0.8]		k3;
[0.5]		k4;
[1]		d;
[0.00005]	m1;
[20.0]		z0;
[62.5]		tao;
[10.0]		r1;
[4.0]		r0;
[0] c1;
[0] c2;
[0] c3;

[0, 100]	time;

[5.0, 7.0]	x;
[0.5, 2.0]	y;
[28.0, 40.0]	z;
[6.0, 7.0]	v;

{
	mode 1;


    	invt:
	 (>= x 5.0);
 	 (>= y 0.5);
 	 (>= z 28.0);
	 (>= v 6.0);

	flow:
		d/dt[x] = (* 50.0 (+ (* (- (- (* alphax (+ k1 (* (- 1 k1) (/ z (+ z k2))))) (* betax (+ k3 (* (- 1 k3) (/ z (+ z k4)))))) (* m1 (- 1 (/ z z0)))) x) (* c1 x)) );
		d/dt[y] = (* 50.0 (+ (+ (* (* m1 (- 1 (/ z z0))) x) (* (- (* alphay (- 1 (* d (/ z z0)))) betay) y)) (* c2 y)));
		d/dt[z] = (* 50.0 (+ (* (- 0 1) (/ z tao))(* c3 z)));
		d/dt[v] = (* 50.0 (+ (+ (* (- (- (* alphax (+ k1 (* (- 1 k1) (/ z (+ z k2))))) (* betax (+ k3 (* (- 1 k3) (/ z (+ z k4)))))) (* m1 (- 1 (/ z z0)))) x) (* c1 x)) (+ (+ (* (* m1 (- 1 (/ z z0))) x) (* (- (* alphay (- 1 (* d (/ z z0)))) betay) y)) (* c2 y)) ));
	jump:
		(and (>= (+ x y)  r1) (>= (+ (+ (* (- (- (* alphax (+ k1 (* (- 1 k1) (/ z (+ z k2))))) (* betax (+ k3 (* (- 1 k3) (/ z (+ z k4)))))) (* m1 (- 1 (/ z z0)))) x) (* c1 x)) (+ (+ (* (* m1 (- 1 (/ z z0))) x) (* (- (* alphay (- 1 (* d (/ z z0)))) betay) y)) (* c2 y)) ) 0)) ==> @2 (and (= x' x) (= y' y) (= z' z) (= v' v));
}

{
	mode 2;


    	invt:
	 (>= x 5.0);
 	 (>= y 0.5);
 	 (>= z 28.0);
	 (>= v 6.0);
	flow:
		d/dt[x] = (* 50.0 (+ (* (- (- (* alphax (+ k1 (* (- 1 k1) (/ z (+ z k2))))) (* betax (+ k3 (* (- 1 k3) (/ z (+ z k4)))))) (* m1 (- 1 (/ z z0)))) x) (* c1 x)));
		d/dt[y] = (* 50.0 (+ (+ (* (* m1 (- 1 (/ z z0))) x) (* (- (* alphay (- 1 (* d (/ z z0)))) betay) y)) (* c2 y)));
		d/dt[z] = (* 50.0 (+ (/ (- z0 z) tao) (* c3 z)));
		d/dt[v] = (* 50.0 (+ (+ (* (- (- (* alphax (+ k1 (* (- 1 k1) (/ z (+ z k2))))) (* betax (+ k3 (* (- 1 k3) (/ z (+ z k4)))))) (* m1 (- 1 (/ z z0)))) x) (* c1 x)) (+ (+ (* (* m1 (- 1 (/ z z0))) x) (* (- (* alphay (- 1 (* d (/ z z0)))) betay) y)) (* c2 y)) )) ;
	jump:
		(and (<= (+ x y)  r1) (>= (+ (+ (* (- (- (* alphax (+ k1 (* (- 1 k1) (/ z (+ z k2))))) (* betax (+ k3 (* (- 1 k3) (/ z (+ z k4)))))) (* m1 (- 1 (/ z z0)))) x) (* c1 x)) (+ (+ (* (* m1 (- 1 (/ z z0))) x) (* (- (* alphay (- 1 (* d (/ z z0)))) betay) y)) (* c2 y)) ) 0)) ==> @1 (and (= x' x) (= y' y) (= z' z) (= v' v));
}

init:

@1	(and (= x 5) (= y 1) (= z 30) (= v 6));

goal:

@1	(and (>= x 5.0)
	(>= y 0.5)
	(>= z 28.0)
	(>= v 6.0));
