[0.0204]	alphax;
[0.0242]	alphay;
[0.0076]	betax;
[0.0168]	betay;
[0.0]		k1;
[2.0]		k2;
[0.8]		k3;
[0.5]		k4;
[0, 1]		d;
[0.00005]	m1;
[20.0]		z0;
[62.5]		tao;
[10.0]		r1;
[4.0]		r0;
[0] c1;
[0] c2;
[0] c3;
[0, 2500]	time;

[0.0, 100.0]	x;
[0.0, 100.0]	y;
[0.0, 100.0]	z;
[0.0, 100.0]	v;

%%

{
	mode 1;


    	invt:
		(>= x 0);
		(>= y 0);
		(>= z 0);
		(>= v 0);
	flow:
		d/dt[x] = (+ (* (- (- (* alphax (+ k1 (* (- 1 k1) (/ z (+ z k2))))) (* betax (+ k3 (* (- 1 k3) (/ z (+ z k4)))))) (* m1 (- 1 (/ z z0)))) x) (* c1 x));
		d/dt[y] = (+ (+ (* (* m1 (- 1 (/ z z0))) x) (* (- (* alphay (- 1 (* d (/ z z0)))) betay) y)) (* c2 y));
		d/dt[z] = (+ (* -1 (/ z tao))(* c3 z));
		d/dt[v] = (+ (+ (* (- (- (* alphax (+ k1 (* (- 1 k1) (/ z (+ z k2))))) (* betax (+ k3 (* (- 1 k3) (/ z (+ z k4)))))) (* m1 (- 1 (/ z z0)))) x) (* c1 x)) (+ (+ (* (* m1 (- 1 (/ z z0))) x) (* (- (* alphay (- 1 (* d (/ z z0)))) betay) y)) (* c2 y)) );
	jump:
		(and (>= (+ x y)  r1) (> (+ (+ (* (- (- (* alphax (+ k1 (* (- 1 k1) (/ z (+ z k2))))) (* betax (+ k3 (* (- 1 k3) (/ z (+ z k4)))))) (* m1 (- 1 (/ z z0)))) x) (* c1 x)) (+ (+ (* (* m1 (- 1 (/ z z0))) x) (* (- (* alphay (- 1 (* d (/ z z0)))) betay) y)) (* c2 y)) ) 0)) ==> @2 (and (= x' x) (= y' y) (= z' z) (= v' v));
}

{
	mode 2;


    	invt:
		(>= x 0);
		(>= y 0);
		(>= z 0);
		(>= v 0);
	flow:
		d/dt[x] = (+ (* (- (- (* alphax (+ k1 (* (- 1 k1) (/ z (+ z k2))))) (* betax (+ k3 (* (- 1 k3) (/ z (+ z k4)))))) (* m1 (- 1 (/ z z0)))) x) (* c1 x));
		d/dt[y] = (+ (+ (* (* m1 (- 1 (/ z z0))) x) (* (- (* alphay (- 1 (* d (/ z z0)))) betay) y)) (* c2 y));
		d/dt[z] = (+ (/ (- z0 z) tao) (* c3 z));
		d/dt[v] = (+ (+ (* (- (- (* alphax (+ k1 (* (- 1 k1) (/ z (+ z k2))))) (* betax (+ k3 (* (- 1 k3) (/ z (+ z k4)))))) (* m1 (- 1 (/ z z0)))) x) (* c1 x)) (+ (+ (* (* m1 (- 1 (/ z z0))) x) (* (- (* alphay (- 1 (* d (/ z z0)))) betay) y)) (* c2 y)) );
	jump:
		(and (< (+ x y)  r0) (> (+ (+ (* (- (- (* alphax (+ k1 (* (- 1 k1) (/ z (+ z k2))))) (* betax (+ k3 (* (- 1 k3) (/ z (+ z k4)))))) (* m1 (- 1 (/ z z0)))) x) (* c1 x)) (+ (+ (* (* m1 (- 1 (/ z z0))) x) (* (- (* alphay (- 1 (* d (/ z z0)))) betay) y)) (* c2 y)) ) 0)) ==> @1 (and (= x' x) (= y' y) (= z' z) (= v' v));
}


%%

init:

@1	(and (= x 5) (= y 1) (= z 30) (= v 6));

goal:

@1	(and (>= x 0)
	(< y 2)
	(>= z 0)
	(>= v 0));




