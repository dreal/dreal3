/// @addtogroup homology
/// @{

/////////////////////////////////////////////////////////////////////////////
///
/// @file cubchain.cpp
///
/// @author Pawel Pilarczyk
///
/////////////////////////////////////////////////////////////////////////////

// Copyright (C) 1997-2010 by Pawel Pilarczyk.
//
// This file constitutes a part of the Homology Library, 
// distributed under the terms of the GNU General Public License.
// Consult  http://capd.wsb-nlu.edu.pl/ for details. 

// Started in August 1997. Last revision: September 27, 2004.


#include "capd/homology/config.h"
#include "capd/homology/textfile.h"
#include "capd/homology/cubisets.h"
#include "capd/homology/homtools.h"
#include "capd/homology/timeused.h"
#include "capd/homology/arg.h"

#include <exception>
#include <cstdlib>
#include <new>
#include <iostream>
#include <fstream>

using namespace capd::homology;


// --------------------------------------------------
// -------------------- OVERTURE --------------------
// --------------------------------------------------

const char *title = "\
CUBCHAIN, ver. 2.10. Copyright (C) 1997-2010 by Pawel Pilarczyk.\n\
This is free software. No warranty. Consult 'license.txt' for details.";

const char *helpinfo = "\
Call with: X.cub [A.cub] CX.chn <OR> -c X.cel [A.cel] CX.chn.\n\
This program creates a chain complex in the format compatible with\n\
'homchain' from sets built of n-dimensional hypercubes in R^n.\n\
If two input file names are specified, a quotient chain complex of this\n\
pair of spaces is created.\n\
Input data lines define either full-dimensional cubes represented by the\n\
vertex with minimal coordinates - e.g. \"(1,3)\" defines the 2-dimensional\n\
cube (that is, square) which is the product of intervals [1,2] and [3,4].\n\
If the '-c' switch is used, then each line of the input file(s) is assumed\n\
to contain the definition of a cubical cell as a Cartesian product of\n\
(possibly degenerated) intervals, e.g., \"[1,2]x[3]x[8,9]\", or as a cell\n\
spanned between two opposite vertices - one with minimal coordinates, the\n\
other one with maximal, e.g., \"[(1,3,8) (2,3,9)]\". As a last resort,\n\
a line that looks like a cube, e.g., \"(3,8,12)\", is interpreted as a\n\
cubical cell of maximal dimension - here [3,4]x[8,9]x[12,13].\n\
Optional arguments:\n\
-c - read the data files as sets of cubical cells, not sets of cubes,\n\
-d - use digital names (numbers) to save space and to use 'homchain -d'.\n\
-s - use symbolic names for cubical cells (opposite to '-d'; default),\n\
-p - write symbolic names of cells as products of intervals (unless '-d'),\n\
-wn - wrap space every n units (repeat for each axis separately),\n\
-h - display this brief help information only and exit.\n\
For more information ask the author at http://www.PawelPilarczyk.com/.";


// --------------------------------------------------
// -------------------- CUBCHAIN --------------------
// --------------------------------------------------

static int readcubesorcells (const char *filename, cubes &Xcubes,
	cubicalcomplex &Xcompl, const char *name, bool cubicalcells)
// Read a set of cubes or cells (depending of 'cubicalcells') from a file.
{
	// if there is no file given, do nothing
	if (!filename)
		return 0;

	// say what you are going to do
	sout << "Reading " << name << " from '" << filename << "'... ";

	// open the input file
	std::ifstream in (filename);
	if (!in)
		fileerror (filename);

	// ignore the entire line starting with "dimension" if there is any
	ignorecomments (in);
	if ((in. peek () == 'd') || (in. peek () == 'D'))
		ignoreline (in);

	// read the set of cubes or the set of cells
	if (cubicalcells)
		in >> Xcompl;
	else
		in >> Xcubes;

	// say what has been read
	sout << (Xcubes. size () + Xcompl. size ()) <<
		(cubicalcells ? " cells" : " cubes") << " read.\n";

	return 0;
} /* readcubesorcells */

static int writechaincomplex (const cubicalcomplex &Xcompl,
	const char *Xname, const char *Aname,
	const char *outname, bool cubicalcells, bool symbolicnames)
// Write a chain complex of the given cubical complex to an output file.
{
	if (!outname)
		return 0;
	sout << "Writing the chain complex to '" << outname << "'... ";
	std::ofstream out (outname);
	if (!out)
		fileerror (outname, "create");
	out << "; This is a chain complex generated by CUBCHAIN\n";
	out << "; from the " << (cubicalcells ? "cells" : "cubes") <<
		" stored in '" << Xname;
	if (Aname)
		out << "' and '" << Aname;
	out << "'.\n";

	writechaincomplex (out, Xcompl, symbolicnames);

	sout << "Done.\n";
	return 0;
} /* writechaincomplex */

static int cubchain (char *Xname, char *Aname, char *outname,
	bool cubicalcells, bool symbolicnames)
// Write a chain complex of a set of cubes or cells - the main procedure.
// Return: 0 = Ok, -1 = Error (show messages).
{
	// read the first set of cubes or cells
	cubes Xcubes;
	cubicalcomplex Xcompl;
	readcubesorcells (Xname, Xcubes, Xcompl, "X", cubicalcells);

	// read the second set of cubes or cells if any
	cubes Acubes;
	cubicalcomplex Acompl;
	readcubesorcells (Aname, Acubes, Acompl, "A", cubicalcells);

	// remove from X cubes which are in A
	if (!Acubes. empty ())
	{
		removeAfromX (Xcubes, Acubes, "X", "A");

		// if the set X is empty, the answer is obvious
		if (Xcubes. empty ())
		{
			sout << "The set X is contained in A. The relative "
				"chain complex of (X,A) is trivial.\n";
			return 0;
		}
	}

	// transform both sets of cubes into sets of cubical cells
        cubes2cells (Xcubes, Xcompl, "X", true);
	cubes2cells (Acubes, Acompl, "A", true);

	// decrease the dimension of A to the dimension of X
	if (Acompl. dim () > Xcompl. dim ())
		decreasedimension (Acompl, Xcompl. dim (), "A");

	// remove from X cells which are in A
	if (cubicalcells)
	{
		removeAfromX (Xcompl, Acompl, "X", "A");

		// if the set X is empty, the answer is obvious
		if (Xcompl. empty ())
		{
			sout << "The set X is contained in A. The relative "
				"chain complex of (X,A) is trivial.\n";
			return 0;
		}
	}

	// create a full cubical complex (with all the faces) of X\A
	addboundaries (Xcompl, Acompl, 0, false, "X", "A");

	// write the chain complex to a file
	writechaincomplex (Xcompl, Xname, Aname, outname, cubicalcells,
		symbolicnames);

	return 0;
} /* cubchain */


// --------------------------------------------------
// ---------------------- MAIN ----------------------
// --------------------------------------------------

int main (int argc, char *argv [])
// Return: 0 = Ok, -1 = Error, 1 = Help displayed, 2 = Wrong arguments.
{
	// prepare user-configurable data
	char *Xname = NULL, *Aname = NULL, *outname = NULL;
	coordinate wrap [qcell::MaxDim];
	for (int i = 0; i < qcell::MaxDim; i ++)
		wrap [i] = 0;
	int wrapcount = 0;
	bool cubicalcells = false;
	bool symbolicnames = true;
	bool products = false;

	// interprete the command-line arguments
	arguments a;
	arg (a, NULL, Xname);
	arg (a, NULL, Aname);
	arg (a, NULL, outname);
	arg (a, "w", wrap, wrapcount, qcell::MaxDim);
	argswitch (a, "c", cubicalcells, true);
	argswitch (a, "s", symbolicnames, true);
	argswitch (a, "d", symbolicnames, false);
	argswitch (a, "p", products, true);
	arghelp (a);

	argstreamprepare (a);
	int argresult = a. analyze (argc, argv);
	argstreamset ();

	// show the program's main title
	if (argresult >= 0)
		sout << title << '\n';

	// set the space wrapping if necessary
	if (wrapcount == 1)
		PointBase::setwrapping (wrap [0]);
	else if (wrapcount)
		PointBase::setwrapping (wrap);

	// shift names if necessary
	if (!outname)
	{
		outname = Aname;
		Aname = NULL;
	}

	// remove the space between vertices for symbolic names
	CubicalCell::OutputBits &= ~CubicalCell::BitSpace;

	// display symbolic names as Cartesian products if requested to
	if (products)
		CubicalCell::OutputBits |= CubicalCell::BitProduct;
	
	// if something was incorrect, show an additional message and exit
	if (argresult < 0)
	{
		sout << "Call with '--help' for help.\n";
		return 2;
	}

	// if help requested or no filenames present, show help information
	if (!Xname || !outname || (argresult > 0))
	{
		sout << helpinfo << '\n';
		return 1;
	}

	// try running the main function and catch an error message if thrown
	try
	{
		cubchain (Xname, Aname, outname, cubicalcells,
			symbolicnames);
		program_time = 1;
		return 0;
	}
	catch (const char *msg)
	{
		sout << "ERROR: " << msg << '\n';
		return -1;
	}
	catch (const std::exception &e)
	{
		sout << "ERROR: " << e. what () << '\n';
		return -1;
	}
	catch (...)
	{
		sout << "ABORT: An unknown error occurred.\n";
		return -1;
	}
} /* main */

/// @}

